// Copyright 2018 Google LLC
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

use clap::{App, Arg};
use std::{io, net::SocketAddr};
use tarpc::{client, context, tokio_serde::formats::Json};

#[tokio::main]
async fn main() -> io::Result<()> {
    env_logger::init();

    let flags = App::new("Graph Remote Calls")
        .version("0.1")
        .author("Animesh Sinha <animesh.sinha@research.iiit.ac.in>")
        .about("Implements Prims MST as a remote procedure call.")
        .arg(
            Arg::with_name("server_addr")
                .long("server_addr")
                .value_name("ADDRESS")
                .help("Sets the server address to connect to.")
                .required(true)
                .takes_value(true),
        )
        .get_matches();

    let server_addr = flags.value_of("server_addr").unwrap();
    let server_addr = server_addr
        .parse::<SocketAddr>()
        .unwrap_or_else(|e| panic!(r#"--server_addr value "{}" invalid: {}"#, server_addr, e));

    let mut transport = tarpc::serde_transport::tcp::connect(server_addr, Json::default);
    transport.config_mut().max_frame_length(4294967296);

    // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
    // config and any Transport as input.
    let mut client =
        service::WorldClient::new(client::Config::default(), transport.await?).spawn()?;

    // The client has an RPC method for each RPC defined in the annotated trait. It takes the same
    // args as defined, with the addition of a Context, which is always the first arg. The Context
    // specifies a deadline and trace information which can be helpful in debugging requests.
    let hello = client.hello(context::current(), name).await?;
    println!("{}", hello);

    let stdin = io::stdin();
    loop {
        let mut inp = String::new();
        stdin.read_line(&mut inp).unwrap();
        if inp.is_empty() {
            break;
        }
        let tokens: Vec<&str> = inp.trim().split(" ").collect();
        if tokens[0] == "new_graph" {
            let name: String = tokens[1].to_string();
            let num_nodes: usize = tokens[2].parse::<usize>().unwrap();
            client.new_graph(context::current(), name, num_nodes).await?;
        } else if tokens[0] == "add_edge" {
            let name: String = tokens[1].to_string();
            let u: usize = tokens[2].parse::<usize>().unwrap();
            let v: usize = tokens[3].parse::<usize>().unwrap();
            let w: usize = tokens[4].parse::<usize>().unwrap();
            client.add_edge(context::current(), name, u, v, w).await?;
        } else if tokens[0] == "get_mst" {
            let name: String = tokens[1].to_string();
            let num: usize = client.get_mst(context::current(), name).await?;
            println!("{}", num);
        } else if tokens[0] == "get_details" {
            let name: String = tokens[1].to_string();
            let result: String = client.get_details(context::current(), name).await?;
            println!("{}", result);
        } else if tokens[0] == "q" {
            break;
        }
    }

    Ok(())
}
